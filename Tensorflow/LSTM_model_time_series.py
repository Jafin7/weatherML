# -*- coding: utf-8 -*-
"""Time Series.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rfvU_v7JmjMHMH90NaYDi6ogGIUIQdJb

Download the sample dataset from Keras Datasets.
---
wget function directly downloads the zip file.

unzip to extract the file.

Renamed to weather.csv file for further usage.


!wget https://storage.googleapis.com/tensorflow/tf-keras-datasets/jena_climate_2009_2016.csv.zip -O weather.zip
!rm -rf sample_data
!unzip weather.zip
!rm weather.zip
!mv jena_climate_2009_2016.csv weather.csv
"""
# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
# %tensorflow_version 2.x
import tensorflow as tf
tf.__version__

data = pd.read_csv("weather.csv")
#data.head()

temp_data = data['T (degC)']
temp_data.index = data['Date Time']

#Split the dataset and get mean, standard deviation, and then standardize the temperature data

split = 300000
temp_data = temp_data.values

temp_mean = temp_data[:split].mean()
temp_stdv = temp_data[:split].std()
temp_std = (temp_data - temp_mean) / temp_stdv

past_data = 20
target_data = 0

data = []
labels = []

start_index = 0 + past_data
end_index = split

for i in range(start_index, end_index):
  index = range(i-past_data, i)
  data.append(np.reshape(temp_std[index], (past_data, 1)))
  labels.append(temp_std[i+target_data])
x,y = np.array(data), np.array(labels)

def create_time_steps(length):
  return list(range(-length, 0))

plot_data = [x[0],y[0]]
delta = 0
labels = ['Previous data', 'Next Real Data', 'Model Prediction']
marker = ['.-', 'rx', 'go']
time_steps = create_time_steps(plot_data[0].shape[0])
if delta:
  future = delta
else:
  future = 0

plt.title("Example")

for i, xe in enumerate(plot_data):
  if i:
    plt.plot(future, plot_data[i], marker[i], markersize=10, label=labels[i])
  else:
    plt.plot(time_steps, plot_data[i].flatten(), marker[i], label=labels[i])
plt.legend()
plt.xlim([time_steps[0], (future+5)*2])
plt.xlabel('Time-Step')

def baseline(history):
  return np.mean(history)

train_univariate = tf.data.Dataset.from_tensor_slices((x, y))
train_univariate = train_univariate.cache().shuffle(256).batch(10000).repeat()
val_univariate = tf.data.Dataset.from_tensor_slices((x, y))
val_univariate = val_univariate.batch(256).repeat()

lstm = tf.keras.models.Sequential([tf.keras.layers.LSTM(8, input_shape=x.shape[-2:]), tf.keras.layers.Dense(1)])
lstm.compile(optimizer='adam', loss='mae')

EVALUATION_INTERVAL = 1000
EPOCHS = 10

lstm.fit(train_univariate, epochs=EPOCHS, steps_per_epoch=EVALUATION_INTERVAL, validation_data=val_univariate, validation_steps=50)

for xx, yy in val_univariate.take(3):
  plot_data = [xx[0].numpy(), yy[0].numpy(), lstm.predict(xx)[0]]
  delta = 0
  labels = ['Previous data', 'Next Real Data', 'Predicted value']
  marker = ['.-', 'rx', 'go']
  time_steps = create_time_steps(plot_data[0].shape[0])
  if delta:
    future = delta
  else:
    future = 0

  plt.title("LSTM Model")
  plt.plot(time_steps, plot_data[0].flatten(), marker[0], label=labels[0])
  plt.plot(future, plot_data[1], marker[1], markersize=10, label=labels[1])
  plt.plot(future, plot_data[2], marker[2], markersize=10, label=labels[2])  
  #plt.legend()
  plt.xlim([time_steps[0], (future+5)*2])
  plt.xlabel('Time-Step')
